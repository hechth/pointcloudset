<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>lidar.frame API documentation</title>
<meta name="description" content="Frame Class â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lidar.frame</code></h1>
</header>
<section id="section-intro">
<h1 id="frame-class">Frame Class.</h1>
<p>For one lidar measurement frame. Typically an automotive lidar records many frames per
second.</p>
<p>One Frame consists mainly of pyntcloud pointcloud (.pointcloud) and a pandas dataframe
(.data) with all the associated data.</p>
<p>Note that the index of the points is not preserved when applying processing. This
is necessary since pyntcloud does not allow to pass the index. Therefore, a new
Frame object is generated at each processing stage.</p>
<h2 id="developer-notes">Developer notes:</h2>
<ul>
<li>All operations have to act on both, pointcloud and data and keep the timestamp.</li>
<li>All processing methods need to return another Frame.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Frame Class.

For one lidar measurement frame. Typically an automotive lidar records many frames per
second.

One Frame consists mainly of pyntcloud pointcloud (.pointcloud) and a pandas dataframe
(.data) with all the associated data.

Note that the index of the points is not preserved when applying processing. This
is necessary since pyntcloud does not allow to pass the index. Therefore, a new
Frame object is generated at each processing stage.

## Developer notes:
* All operations have to act on both, pointcloud and data and keep the timestamp.
* All processing methods need to return another Frame.
&#34;&#34;&#34;
from __future__ import annotations

import operator
import traceback
import warnings
from datetime import datetime
from pathlib import Path
from typing import List, Union

import numpy as np
import open3d as o3d
import pandas as pd
import pyntcloud
import rospy

from .convert import convert
from .geometry import plane
from .plot.frame import plot_overlay, plotly_3d, pyntcloud_3d

ops = {
    &#34;&gt;&#34;: operator.gt,
    &#34;&lt;&#34;: operator.lt,
    &#34;&gt;=&#34;: operator.ge,
    &#34;&lt;=&#34;: operator.le,
    &#34;==&#34;: operator.eq,
}


class Frame:
    def __init__(
        self,
        data: pd.DataFrame,
        orig_file: str = &#34;&#34;,
        timestamp: rospy.rostime.Time = rospy.rostime.Time(),
    ):
        &#34;&#34;&#34;One Frame of lidar measurements.

        Example:
        testbag = Path().cwd().parent.joinpath(&#34;tests/testdata/test.bag&#34;)
        testset = lidar.Dataset(testbag,topic=&#34;/os1_cloud_node/points&#34;,keep_zeros=False)
        testframe = testset[0]

        &#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;All the data, x,y.z and intensity, range and more&#34;&#34;&#34;
        self.timestamp = timestamp
        &#34;&#34;&#34;ROS timestamp&#34;&#34;&#34;
        self.points = pyntcloud.PyntCloud(self.data[[&#34;x&#34;, &#34;y&#34;, &#34;z&#34;]], mesh=None)
        &#34;&#34;&#34;Pyntcloud object with x,y,z coordinates&#34;&#34;&#34;
        self.measurments = self.data.drop([&#34;x&#34;, &#34;y&#34;, &#34;z&#34;], axis=1)
        &#34;&#34;&#34;Measurments aka. scalar field of values at each point&#34;&#34;&#34;
        self.orig_file = orig_file
        &#34;&#34;&#34;Path to bag file. Defaults to empty&#34;&#34;&#34;

        self._check_index()

    def __str__(self):
        return f&#34;pointcloud: with {len(self)} points, data:{list(self.data.columns)}, from {self.convert_timestamp()}&#34;

    def __len__(self):
        return len(self.data)

    def __getitem__(self, id: Union[int, slice]) -&gt; pd.DataFrame:
        if isinstance(id, slice):
            return self.data.iloc[id]
        elif isinstance(id, int):
            return self.data.iloc[[id]]
        else:
            raise TypeError(&#34;Wrong type {}&#34;.format(type(id).__name__))

    def extract_point(self, id: int, use_orginal_id: bool = False) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Extract a specific point from the Frame defined by the point id. The id
        can be the current index of the data from the Frame or the original_id.

        Args:
            id (int): Id number
            use_orginal_id (bool, optional): Use normal index or the orginal_id.
            Defaults to False.

        Returns:
            pd.DataFrame: a frame which only containse the defined points.
        &#34;&#34;&#34;
        try:
            if use_orginal_id:
                point = self.data[self.data[&#34;original_id&#34;] == id]
                if len(point) == 0:
                    raise IndexError
                elif len(point) != 1:
                    raise Exception()
            else:
                point = pd.DataFrame(self.data.iloc[id]).transpose()
                point = point.astype(dict(self.data.dtypes))
        except IndexError:
            raise IndexError(f&#34;point with {id} does note exist.&#34;)
        except Exception:
            print(traceback.print_exc())
        return point.reset_index(drop=True)

    def add_column(self, column_name: str, values: np.array):
        &#34;&#34;&#34;Adding a new column to the data of the frame.

        Args:
            column_name (str): name of the new column.
            values (np.array): Values of the new column.
        &#34;&#34;&#34;
        self.data[column_name] = values
        return self

    def calculate_distance_to_plane(
        self, plane_model: np.array, absolute_values: bool = True
    ):
        &#34;&#34;&#34;Calculates the distance of each point to a plane and adds it as a column
        to the data of the frame. Uses the plane equation a x + b y + c z + d = 0

        Args:
            plane_model (np.array): [a, b, c, d], could be provided by plane_segmentation
            absolute_values (bool, optional): Calculate absolute distances if True. Defaults to True.
        &#34;&#34;&#34;
        points = self.points.xyz
        distances = np.asarray(
            [plane.distance_to_point(point, plane_model) for point in points]
        )
        if absolute_values:
            distances = np.absolute(distances)
        plane_str = np.array2string(
            plane_model, precision=2, separator=&#34;,&#34;, suppress_small=True
        )
        self.add_column(f&#34;distance to plane: {plane_str}&#34;, distances)
        return self

    def calculate_distance_to_origin(self):
        &#34;&#34;&#34;For each point in the pointcloud calculate the euclidian distance
        to the origin (0,0,0). Adds a new column to the data with the values.
        &#34;&#34;&#34;
        point_a = np.array((0.0, 0.0, 0.0))
        points = self.points.xyz
        distances = np.array([np.linalg.norm(point_a - point) for point in points])
        self.add_column(&#34;distance to origin&#34;, distances)
        return self

    def describe(self):
        &#34;&#34;&#34;Generate descriptive statistics based on .data.describe().
        &#34;&#34;&#34;
        return self.data.describe()

    def get_open3d_points(self) -&gt; o3d.open3d_pybind.geometry.PointCloud:
        &#34;&#34;&#34;Extract points as open3D PointCloud object. Needed for processing with the
        open3d package.

        Returns:
            o3d.open3d_pybind.geometry.PointCloud: the pointcloud
        &#34;&#34;&#34;
        converted = convert.convert_df2pcd(self.points.points)
        assert len(np.asarray(converted.points)) == len(
            self
        ), &#34;len of open3d points should be the same as len of the Frame&#34;
        return convert.convert_df2pcd(self.points.points)

    def convert_timestamp(self) -&gt; str:
        &#34;&#34;&#34;Convert ROS timestamp to human readable date and time.

        Returns:
            str: date time string
        &#34;&#34;&#34;
        return datetime.fromtimestamp(self.timestamp.to_sec()).strftime(
            &#34;%A, %B %d, %Y %I:%M:%S&#34;
        )

    def has_data(self) -&gt; bool:
        &#34;&#34;&#34;Check if lidar frame has data. Data here means point coordinates and
        measruments at each point of the pointcloud.

        Returns:
            bool: `True`` if the lidar frame contains measurment data.
        &#34;&#34;&#34;
        return not self.data.empty

    def plot_interactive(
        self, backend: str = &#34;plotly&#34;, color: str = &#34;intensity&#34;, **kwargs
    ):
        &#34;&#34;&#34;Generate either a plotly or pyntcloud 3D plot.
        (Note: Plotly plots also give index of datapoint in pandas array when hovering
        over datapoint)

        Args:
            backend (str): specify either &#34;plotly&#34; or &#34;pyntcloud&#34; as plot environment
            color (str): name of the column in the data that should be used as color
            array for plotly plots

        Returns:
            np.array: List of distances for each point
        &#34;&#34;&#34;
        args = locals()
        args.update(kwargs)
        backend = args.pop(&#34;backend&#34;)
        if backend == &#34;pyntcloud&#34;:
            return pyntcloud_3d(self, **kwargs)
        elif backend == &#34;plotly&#34;:
            return plotly_3d(self, color=color, **kwargs)
        else:
            raise ValueError(&#34;wrong backend&#34;)

    def plot_overlay(self, frames_dict: dict):
        &#34;&#34;&#34;Overlay the Frame with the plot(s) of other Frames. For example overlay the
        plot with a frame which contains
        a cluster or a plane. Best used with smaller pointclouds.

        Example:

        testframe.plot_overlay({&#34;Plane&#34;: plane,&#34;Cluster 1&#34;: cluster1,
        &#34;Cluster 2&#34;: cluster2})

        Args:
            frames_dict (dict): A dictionary in the form {&#34;Name&#34;, Frame}.
            Can be arbitrarly long,

        Returns:
            plotly.graph_objs._figure.Figure: The interactive plot with overlays.
        &#34;&#34;&#34;
        return plot_overlay(self, frames_dict=frames_dict)

    def apply_filter(self, boolean_array: np.ndarray):
        &#34;&#34;&#34;Generating a new Frame by removing points where filter is False.
        Usefull for pyntcloud generate boolean arrays and by filtering DataFrames.

        Args:
            boolean_array (np.ndarray): True where the point should remain.

        Returns:
            Frame: Frame with filterd rows and reindexed data and points.
        &#34;&#34;&#34;
        new_data = self.data.loc[boolean_array].reset_index(drop=True)
        return Frame(new_data, timestamp=self.timestamp)

    def select_by_index(self, index_to_keep: List[int]):
        &#34;&#34;&#34;Generating a new Frame by keeping index_to_keep.

        Usefull for open3d generate index lists. Similar to the the select_by_index
        function of open3d.

        Args:
            index_to_keep (List[int]): List of indices to keep

        Returns:
            Frame: Frame with kept rows and reindexed data and points
        &#34;&#34;&#34;
        new_data = self.data.iloc[index_to_keep].reset_index(drop=True)
        return Frame(new_data, timestamp=self.timestamp)

    def limit(self, dim: &#34;str&#34;, minvalue: float, maxvalue: float):
        &#34;&#34;&#34;Limit the range of certain values in lidar Frame. Can be chained together.

        Example:

        testframe.limit(&#34;x&#34;, -1.0, 1.0).limit(&#34;intensity&#34;, 0.0, 50.0)

        Args:
            dim (str): dimension to limit, any column in data not just x, y, or z
            minvalue (float): min value to limit. (greater equal)
            maxvalue (float): max value to limit. (smaller equal)
        Returns:
            Frame: limited frame, were columns which did not match the criteria were
            dropped.
        &#34;&#34;&#34;
        if maxvalue &lt; minvalue:
            raise ValueError(&#34;maxvalue must be greater than minvalue&#34;)
        bool_array = (
            (self.data[dim] &lt;= maxvalue) &amp; (self.data[dim] &gt;= minvalue)
        ).to_numpy()
        return self.apply_filter(bool_array)

    def get_cluster(self, eps: float, min_points: int) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Get the clusters based on open3D cluster_dbscan. Process futher with
            take_cluster.

        Args:
            eps (float): Density parameter that is used to find neighbouring points.
            min_points (int): Minimum number of points to form a cluster.

        Returns:
            pd.DataFrame: Dataframe with list of clusters.
        &#34;&#34;&#34;
        labels = np.array(
            self.get_open3d_points().cluster_dbscan(
                eps=eps, min_points=min_points, print_progress=False
            )
        )
        labels_df = pd.DataFrame(labels, columns=[&#34;cluster&#34;])
        return labels_df

    def take_cluster(self, cluster_number: int, cluster_labels: pd.DataFrame):
        &#34;&#34;&#34;Takes only the points belonging to the cluster_number.

        Args:
            cluster_number (int): Cluster id to keep.
            cluster_labels (pd.DataFrame): clusters generated with get_cluster.

        Returns:
            Frame: with cluster of ID cluster_number.
        &#34;&#34;&#34;
        bool_array = (cluster_labels[&#34;cluster&#34;] == cluster_number).values
        return self.apply_filter(bool_array)

    def remove_radius_outlier(self, nb_points: int, radius: float):
        &#34;&#34;&#34;    Function to remove points that have less than nb_points in a given
        sphere of a given radius Parameters.
        Args:
            nb_points (int) â€“ Number of points within the radius.
            radius (float) â€“ Radius of the sphere.
        Returns:
            Tuple[open3d.geometry.PointCloud, List[int]] :
        &#34;&#34;&#34;
        pcd = self.get_open3d_points()
        cl, index_to_keep = pcd.remove_radius_outlier(
            nb_points=nb_points, radius=radius
        )
        return self.select_by_index(index_to_keep)

    def quantile_filter(
        self, dim: str, relation: str = &#34;&gt;=&#34;, cut_quantile: float = 0.5
    ):
        &#34;&#34;&#34;Filtering based on quantile values of dimension dim of the data.

        Example:

        testframe.quantile_filter(&#34;intensity&#34;,&#34;==&#34;,0.5)

        Args:
            dim (str): column in data, for example &#34;intensity&#34;
            relation (str, optional): Any operator as string. Defaults to &#34;&gt;=&#34;.
            cut_quantile (float, optional): Qunatile to compare to. Defaults to 0.5.

        Returns:
            Frame: Frame which fullfils the criteria.
        &#34;&#34;&#34;
        cut_value = self.data[dim].quantile(cut_quantile)
        filter_array = ops[relation](self.data[dim], cut_value)
        return self.apply_filter(filter_array.to_numpy())

    def plane_segmentation(
        self,
        distance_threshold: float,
        ransac_n: int,
        num_iterations: int,
        return_plane_model: bool = False,
    ):
        &#34;&#34;&#34;Segments a plane in the point cloud using the RANSAC algorithm.
        Based on open3D plane segmentation.

        Args:
            distance_threshold (float): Max distance a point can be from the plane model, and still be considered an inlier.
            ransac_n (int):  Number of initial points to be considered inliers in each iteration.
            num_iterations (int): Number of iterations.
            return_plane_model (bool, optional): Return also plane model parameters. Defaults to False.

        Returns:
            Frame or dict: Frame with inliers or a dict of Frame with inliers and the plane parameters.
        &#34;&#34;&#34;
        pcd = self.get_open3d_points()
        plane_model, inliers = pcd.segment_plane(
            distance_threshold=distance_threshold,
            ransac_n=ransac_n,
            num_iterations=num_iterations,
        )
        if len(self) &gt; 200:
            warnings.warn(
                &#34;&#34;&#34;Might not produce reproducable resuts, If the number of points
                is high. Try to reduce the area of interesst before using
                plane_segmentation. Caused by open3D.&#34;&#34;&#34;
            )
        inlier_Frame = self.select_by_index(inliers)
        if return_plane_model:
            return {&#34;Frame&#34;: inlier_Frame, &#34;plane_model&#34;: plane_model}
        else:
            return inlier_Frame

    def to_csv(self, path: Path = Path()):
        &#34;&#34;&#34;Exports the frame as a csv for use with cloud compare or similar tools.
        Args:
            path (Path, optional): Destination. Defaults to the folder of
            the bag fiile with the timestamp of the frame.
        &#34;&#34;&#34;
        orig_file_name = Path(self.orig_file).stem
        if path == Path():
            filename = f&#34;{orig_file_name}_timestamp_{self.timestamp}.csv&#34;
            destination_folder = Path(self.orig_file).parent.joinpath(filename)
        else:
            destination_folder = path
        self.data.to_csv(destination_folder, index=False)

    def _check_index(self):
        &#34;&#34;&#34;A private function to check if the index of self.data is sane.
        &#34;&#34;&#34;
        if len(self) &gt; 0:
            assert self.data.index[0] == 0, &#34;index should start with 0&#34;
            assert self.data.index[-1] + 1 == len(
                self
            ), &#34;index should be as long as the data&#34;
            assert (
                self.data.index.is_monotonic_increasing
            ), &#34;index should be monotonic increasing&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lidar.frame.Frame"><code class="flex name class">
<span>class <span class="ident">Frame</span></span>
<span>(</span><span>data:Â pd.DataFrame, orig_file:Â strÂ =Â '', timestamp:Â rospy.rostime.TimeÂ =Â rospy.Time[0])</span>
</code></dt>
<dd>
<div class="desc"><p>One Frame of lidar measurements.</p>
<p>Example:
testbag = Path().cwd().parent.joinpath("tests/testdata/test.bag")
testset = lidar.Dataset(testbag,topic="/os1_cloud_node/points",keep_zeros=False)
testframe = testset[0]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Frame:
    def __init__(
        self,
        data: pd.DataFrame,
        orig_file: str = &#34;&#34;,
        timestamp: rospy.rostime.Time = rospy.rostime.Time(),
    ):
        &#34;&#34;&#34;One Frame of lidar measurements.

        Example:
        testbag = Path().cwd().parent.joinpath(&#34;tests/testdata/test.bag&#34;)
        testset = lidar.Dataset(testbag,topic=&#34;/os1_cloud_node/points&#34;,keep_zeros=False)
        testframe = testset[0]

        &#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;All the data, x,y.z and intensity, range and more&#34;&#34;&#34;
        self.timestamp = timestamp
        &#34;&#34;&#34;ROS timestamp&#34;&#34;&#34;
        self.points = pyntcloud.PyntCloud(self.data[[&#34;x&#34;, &#34;y&#34;, &#34;z&#34;]], mesh=None)
        &#34;&#34;&#34;Pyntcloud object with x,y,z coordinates&#34;&#34;&#34;
        self.measurments = self.data.drop([&#34;x&#34;, &#34;y&#34;, &#34;z&#34;], axis=1)
        &#34;&#34;&#34;Measurments aka. scalar field of values at each point&#34;&#34;&#34;
        self.orig_file = orig_file
        &#34;&#34;&#34;Path to bag file. Defaults to empty&#34;&#34;&#34;

        self._check_index()

    def __str__(self):
        return f&#34;pointcloud: with {len(self)} points, data:{list(self.data.columns)}, from {self.convert_timestamp()}&#34;

    def __len__(self):
        return len(self.data)

    def __getitem__(self, id: Union[int, slice]) -&gt; pd.DataFrame:
        if isinstance(id, slice):
            return self.data.iloc[id]
        elif isinstance(id, int):
            return self.data.iloc[[id]]
        else:
            raise TypeError(&#34;Wrong type {}&#34;.format(type(id).__name__))

    def extract_point(self, id: int, use_orginal_id: bool = False) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Extract a specific point from the Frame defined by the point id. The id
        can be the current index of the data from the Frame or the original_id.

        Args:
            id (int): Id number
            use_orginal_id (bool, optional): Use normal index or the orginal_id.
            Defaults to False.

        Returns:
            pd.DataFrame: a frame which only containse the defined points.
        &#34;&#34;&#34;
        try:
            if use_orginal_id:
                point = self.data[self.data[&#34;original_id&#34;] == id]
                if len(point) == 0:
                    raise IndexError
                elif len(point) != 1:
                    raise Exception()
            else:
                point = pd.DataFrame(self.data.iloc[id]).transpose()
                point = point.astype(dict(self.data.dtypes))
        except IndexError:
            raise IndexError(f&#34;point with {id} does note exist.&#34;)
        except Exception:
            print(traceback.print_exc())
        return point.reset_index(drop=True)

    def add_column(self, column_name: str, values: np.array):
        &#34;&#34;&#34;Adding a new column to the data of the frame.

        Args:
            column_name (str): name of the new column.
            values (np.array): Values of the new column.
        &#34;&#34;&#34;
        self.data[column_name] = values
        return self

    def calculate_distance_to_plane(
        self, plane_model: np.array, absolute_values: bool = True
    ):
        &#34;&#34;&#34;Calculates the distance of each point to a plane and adds it as a column
        to the data of the frame. Uses the plane equation a x + b y + c z + d = 0

        Args:
            plane_model (np.array): [a, b, c, d], could be provided by plane_segmentation
            absolute_values (bool, optional): Calculate absolute distances if True. Defaults to True.
        &#34;&#34;&#34;
        points = self.points.xyz
        distances = np.asarray(
            [plane.distance_to_point(point, plane_model) for point in points]
        )
        if absolute_values:
            distances = np.absolute(distances)
        plane_str = np.array2string(
            plane_model, precision=2, separator=&#34;,&#34;, suppress_small=True
        )
        self.add_column(f&#34;distance to plane: {plane_str}&#34;, distances)
        return self

    def calculate_distance_to_origin(self):
        &#34;&#34;&#34;For each point in the pointcloud calculate the euclidian distance
        to the origin (0,0,0). Adds a new column to the data with the values.
        &#34;&#34;&#34;
        point_a = np.array((0.0, 0.0, 0.0))
        points = self.points.xyz
        distances = np.array([np.linalg.norm(point_a - point) for point in points])
        self.add_column(&#34;distance to origin&#34;, distances)
        return self

    def describe(self):
        &#34;&#34;&#34;Generate descriptive statistics based on .data.describe().
        &#34;&#34;&#34;
        return self.data.describe()

    def get_open3d_points(self) -&gt; o3d.open3d_pybind.geometry.PointCloud:
        &#34;&#34;&#34;Extract points as open3D PointCloud object. Needed for processing with the
        open3d package.

        Returns:
            o3d.open3d_pybind.geometry.PointCloud: the pointcloud
        &#34;&#34;&#34;
        converted = convert.convert_df2pcd(self.points.points)
        assert len(np.asarray(converted.points)) == len(
            self
        ), &#34;len of open3d points should be the same as len of the Frame&#34;
        return convert.convert_df2pcd(self.points.points)

    def convert_timestamp(self) -&gt; str:
        &#34;&#34;&#34;Convert ROS timestamp to human readable date and time.

        Returns:
            str: date time string
        &#34;&#34;&#34;
        return datetime.fromtimestamp(self.timestamp.to_sec()).strftime(
            &#34;%A, %B %d, %Y %I:%M:%S&#34;
        )

    def has_data(self) -&gt; bool:
        &#34;&#34;&#34;Check if lidar frame has data. Data here means point coordinates and
        measruments at each point of the pointcloud.

        Returns:
            bool: `True`` if the lidar frame contains measurment data.
        &#34;&#34;&#34;
        return not self.data.empty

    def plot_interactive(
        self, backend: str = &#34;plotly&#34;, color: str = &#34;intensity&#34;, **kwargs
    ):
        &#34;&#34;&#34;Generate either a plotly or pyntcloud 3D plot.
        (Note: Plotly plots also give index of datapoint in pandas array when hovering
        over datapoint)

        Args:
            backend (str): specify either &#34;plotly&#34; or &#34;pyntcloud&#34; as plot environment
            color (str): name of the column in the data that should be used as color
            array for plotly plots

        Returns:
            np.array: List of distances for each point
        &#34;&#34;&#34;
        args = locals()
        args.update(kwargs)
        backend = args.pop(&#34;backend&#34;)
        if backend == &#34;pyntcloud&#34;:
            return pyntcloud_3d(self, **kwargs)
        elif backend == &#34;plotly&#34;:
            return plotly_3d(self, color=color, **kwargs)
        else:
            raise ValueError(&#34;wrong backend&#34;)

    def plot_overlay(self, frames_dict: dict):
        &#34;&#34;&#34;Overlay the Frame with the plot(s) of other Frames. For example overlay the
        plot with a frame which contains
        a cluster or a plane. Best used with smaller pointclouds.

        Example:

        testframe.plot_overlay({&#34;Plane&#34;: plane,&#34;Cluster 1&#34;: cluster1,
        &#34;Cluster 2&#34;: cluster2})

        Args:
            frames_dict (dict): A dictionary in the form {&#34;Name&#34;, Frame}.
            Can be arbitrarly long,

        Returns:
            plotly.graph_objs._figure.Figure: The interactive plot with overlays.
        &#34;&#34;&#34;
        return plot_overlay(self, frames_dict=frames_dict)

    def apply_filter(self, boolean_array: np.ndarray):
        &#34;&#34;&#34;Generating a new Frame by removing points where filter is False.
        Usefull for pyntcloud generate boolean arrays and by filtering DataFrames.

        Args:
            boolean_array (np.ndarray): True where the point should remain.

        Returns:
            Frame: Frame with filterd rows and reindexed data and points.
        &#34;&#34;&#34;
        new_data = self.data.loc[boolean_array].reset_index(drop=True)
        return Frame(new_data, timestamp=self.timestamp)

    def select_by_index(self, index_to_keep: List[int]):
        &#34;&#34;&#34;Generating a new Frame by keeping index_to_keep.

        Usefull for open3d generate index lists. Similar to the the select_by_index
        function of open3d.

        Args:
            index_to_keep (List[int]): List of indices to keep

        Returns:
            Frame: Frame with kept rows and reindexed data and points
        &#34;&#34;&#34;
        new_data = self.data.iloc[index_to_keep].reset_index(drop=True)
        return Frame(new_data, timestamp=self.timestamp)

    def limit(self, dim: &#34;str&#34;, minvalue: float, maxvalue: float):
        &#34;&#34;&#34;Limit the range of certain values in lidar Frame. Can be chained together.

        Example:

        testframe.limit(&#34;x&#34;, -1.0, 1.0).limit(&#34;intensity&#34;, 0.0, 50.0)

        Args:
            dim (str): dimension to limit, any column in data not just x, y, or z
            minvalue (float): min value to limit. (greater equal)
            maxvalue (float): max value to limit. (smaller equal)
        Returns:
            Frame: limited frame, were columns which did not match the criteria were
            dropped.
        &#34;&#34;&#34;
        if maxvalue &lt; minvalue:
            raise ValueError(&#34;maxvalue must be greater than minvalue&#34;)
        bool_array = (
            (self.data[dim] &lt;= maxvalue) &amp; (self.data[dim] &gt;= minvalue)
        ).to_numpy()
        return self.apply_filter(bool_array)

    def get_cluster(self, eps: float, min_points: int) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Get the clusters based on open3D cluster_dbscan. Process futher with
            take_cluster.

        Args:
            eps (float): Density parameter that is used to find neighbouring points.
            min_points (int): Minimum number of points to form a cluster.

        Returns:
            pd.DataFrame: Dataframe with list of clusters.
        &#34;&#34;&#34;
        labels = np.array(
            self.get_open3d_points().cluster_dbscan(
                eps=eps, min_points=min_points, print_progress=False
            )
        )
        labels_df = pd.DataFrame(labels, columns=[&#34;cluster&#34;])
        return labels_df

    def take_cluster(self, cluster_number: int, cluster_labels: pd.DataFrame):
        &#34;&#34;&#34;Takes only the points belonging to the cluster_number.

        Args:
            cluster_number (int): Cluster id to keep.
            cluster_labels (pd.DataFrame): clusters generated with get_cluster.

        Returns:
            Frame: with cluster of ID cluster_number.
        &#34;&#34;&#34;
        bool_array = (cluster_labels[&#34;cluster&#34;] == cluster_number).values
        return self.apply_filter(bool_array)

    def remove_radius_outlier(self, nb_points: int, radius: float):
        &#34;&#34;&#34;    Function to remove points that have less than nb_points in a given
        sphere of a given radius Parameters.
        Args:
            nb_points (int) â€“ Number of points within the radius.
            radius (float) â€“ Radius of the sphere.
        Returns:
            Tuple[open3d.geometry.PointCloud, List[int]] :
        &#34;&#34;&#34;
        pcd = self.get_open3d_points()
        cl, index_to_keep = pcd.remove_radius_outlier(
            nb_points=nb_points, radius=radius
        )
        return self.select_by_index(index_to_keep)

    def quantile_filter(
        self, dim: str, relation: str = &#34;&gt;=&#34;, cut_quantile: float = 0.5
    ):
        &#34;&#34;&#34;Filtering based on quantile values of dimension dim of the data.

        Example:

        testframe.quantile_filter(&#34;intensity&#34;,&#34;==&#34;,0.5)

        Args:
            dim (str): column in data, for example &#34;intensity&#34;
            relation (str, optional): Any operator as string. Defaults to &#34;&gt;=&#34;.
            cut_quantile (float, optional): Qunatile to compare to. Defaults to 0.5.

        Returns:
            Frame: Frame which fullfils the criteria.
        &#34;&#34;&#34;
        cut_value = self.data[dim].quantile(cut_quantile)
        filter_array = ops[relation](self.data[dim], cut_value)
        return self.apply_filter(filter_array.to_numpy())

    def plane_segmentation(
        self,
        distance_threshold: float,
        ransac_n: int,
        num_iterations: int,
        return_plane_model: bool = False,
    ):
        &#34;&#34;&#34;Segments a plane in the point cloud using the RANSAC algorithm.
        Based on open3D plane segmentation.

        Args:
            distance_threshold (float): Max distance a point can be from the plane model, and still be considered an inlier.
            ransac_n (int):  Number of initial points to be considered inliers in each iteration.
            num_iterations (int): Number of iterations.
            return_plane_model (bool, optional): Return also plane model parameters. Defaults to False.

        Returns:
            Frame or dict: Frame with inliers or a dict of Frame with inliers and the plane parameters.
        &#34;&#34;&#34;
        pcd = self.get_open3d_points()
        plane_model, inliers = pcd.segment_plane(
            distance_threshold=distance_threshold,
            ransac_n=ransac_n,
            num_iterations=num_iterations,
        )
        if len(self) &gt; 200:
            warnings.warn(
                &#34;&#34;&#34;Might not produce reproducable resuts, If the number of points
                is high. Try to reduce the area of interesst before using
                plane_segmentation. Caused by open3D.&#34;&#34;&#34;
            )
        inlier_Frame = self.select_by_index(inliers)
        if return_plane_model:
            return {&#34;Frame&#34;: inlier_Frame, &#34;plane_model&#34;: plane_model}
        else:
            return inlier_Frame

    def to_csv(self, path: Path = Path()):
        &#34;&#34;&#34;Exports the frame as a csv for use with cloud compare or similar tools.
        Args:
            path (Path, optional): Destination. Defaults to the folder of
            the bag fiile with the timestamp of the frame.
        &#34;&#34;&#34;
        orig_file_name = Path(self.orig_file).stem
        if path == Path():
            filename = f&#34;{orig_file_name}_timestamp_{self.timestamp}.csv&#34;
            destination_folder = Path(self.orig_file).parent.joinpath(filename)
        else:
            destination_folder = path
        self.data.to_csv(destination_folder, index=False)

    def _check_index(self):
        &#34;&#34;&#34;A private function to check if the index of self.data is sane.
        &#34;&#34;&#34;
        if len(self) &gt; 0:
            assert self.data.index[0] == 0, &#34;index should start with 0&#34;
            assert self.data.index[-1] + 1 == len(
                self
            ), &#34;index should be as long as the data&#34;
            assert (
                self.data.index.is_monotonic_increasing
            ), &#34;index should be monotonic increasing&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="lidar.frame.Frame.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>All the data, x,y.z and intensity, range and more</p></div>
</dd>
<dt id="lidar.frame.Frame.measurments"><code class="name">var <span class="ident">measurments</span></code></dt>
<dd>
<div class="desc"><p>Measurments aka. scalar field of values at each point</p></div>
</dd>
<dt id="lidar.frame.Frame.orig_file"><code class="name">var <span class="ident">orig_file</span></code></dt>
<dd>
<div class="desc"><p>Path to bag file. Defaults to empty</p></div>
</dd>
<dt id="lidar.frame.Frame.points"><code class="name">var <span class="ident">points</span></code></dt>
<dd>
<div class="desc"><p>Pyntcloud object with x,y,z coordinates</p></div>
</dd>
<dt id="lidar.frame.Frame.timestamp"><code class="name">var <span class="ident">timestamp</span></code></dt>
<dd>
<div class="desc"><p>ROS timestamp</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lidar.frame.Frame.add_column"><code class="name flex">
<span>def <span class="ident">add_column</span></span>(<span>self, column_name:Â str, values:Â np.array)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding a new column to the data of the frame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the new column.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Values of the new column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_column(self, column_name: str, values: np.array):
    &#34;&#34;&#34;Adding a new column to the data of the frame.

    Args:
        column_name (str): name of the new column.
        values (np.array): Values of the new column.
    &#34;&#34;&#34;
    self.data[column_name] = values
    return self</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.apply_filter"><code class="name flex">
<span>def <span class="ident">apply_filter</span></span>(<span>self, boolean_array:Â np.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Generating a new Frame by removing points where filter is False.
Usefull for pyntcloud generate boolean arrays and by filtering DataFrames.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>boolean_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>True where the point should remain.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>Frame with filterd rows and reindexed data and points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_filter(self, boolean_array: np.ndarray):
    &#34;&#34;&#34;Generating a new Frame by removing points where filter is False.
    Usefull for pyntcloud generate boolean arrays and by filtering DataFrames.

    Args:
        boolean_array (np.ndarray): True where the point should remain.

    Returns:
        Frame: Frame with filterd rows and reindexed data and points.
    &#34;&#34;&#34;
    new_data = self.data.loc[boolean_array].reset_index(drop=True)
    return Frame(new_data, timestamp=self.timestamp)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.calculate_distance_to_origin"><code class="name flex">
<span>def <span class="ident">calculate_distance_to_origin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>For each point in the pointcloud calculate the euclidian distance
to the origin (0,0,0). Adds a new column to the data with the values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_distance_to_origin(self):
    &#34;&#34;&#34;For each point in the pointcloud calculate the euclidian distance
    to the origin (0,0,0). Adds a new column to the data with the values.
    &#34;&#34;&#34;
    point_a = np.array((0.0, 0.0, 0.0))
    points = self.points.xyz
    distances = np.array([np.linalg.norm(point_a - point) for point in points])
    self.add_column(&#34;distance to origin&#34;, distances)
    return self</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.calculate_distance_to_plane"><code class="name flex">
<span>def <span class="ident">calculate_distance_to_plane</span></span>(<span>self, plane_model:Â np.array, absolute_values:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the distance of each point to a plane and adds it as a column
to the data of the frame. Uses the plane equation a x + b y + c z + d = 0</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plane_model</code></strong> :&ensp;<code>np.array</code></dt>
<dd>[a, b, c, d], could be provided by plane_segmentation</dd>
<dt><strong><code>absolute_values</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Calculate absolute distances if True. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_distance_to_plane(
    self, plane_model: np.array, absolute_values: bool = True
):
    &#34;&#34;&#34;Calculates the distance of each point to a plane and adds it as a column
    to the data of the frame. Uses the plane equation a x + b y + c z + d = 0

    Args:
        plane_model (np.array): [a, b, c, d], could be provided by plane_segmentation
        absolute_values (bool, optional): Calculate absolute distances if True. Defaults to True.
    &#34;&#34;&#34;
    points = self.points.xyz
    distances = np.asarray(
        [plane.distance_to_point(point, plane_model) for point in points]
    )
    if absolute_values:
        distances = np.absolute(distances)
    plane_str = np.array2string(
        plane_model, precision=2, separator=&#34;,&#34;, suppress_small=True
    )
    self.add_column(f&#34;distance to plane: {plane_str}&#34;, distances)
    return self</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.convert_timestamp"><code class="name flex">
<span>def <span class="ident">convert_timestamp</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert ROS timestamp to human readable date and time.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>date time string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_timestamp(self) -&gt; str:
    &#34;&#34;&#34;Convert ROS timestamp to human readable date and time.

    Returns:
        str: date time string
    &#34;&#34;&#34;
    return datetime.fromtimestamp(self.timestamp.to_sec()).strftime(
        &#34;%A, %B %d, %Y %I:%M:%S&#34;
    )</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate descriptive statistics based on .data.describe().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self):
    &#34;&#34;&#34;Generate descriptive statistics based on .data.describe().
    &#34;&#34;&#34;
    return self.data.describe()</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.extract_point"><code class="name flex">
<span>def <span class="ident">extract_point</span></span>(<span>self, id:Â int, use_orginal_id:Â boolÂ =Â False) â€‘>Â pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Extract a specific point from the Frame defined by the point id. The id
can be the current index of the data from the Frame or the original_id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>Id number</dd>
<dt><strong><code>use_orginal_id</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use normal index or the orginal_id.</dd>
</dl>
<p>Defaults to False.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>a frame which only containse the defined points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_point(self, id: int, use_orginal_id: bool = False) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Extract a specific point from the Frame defined by the point id. The id
    can be the current index of the data from the Frame or the original_id.

    Args:
        id (int): Id number
        use_orginal_id (bool, optional): Use normal index or the orginal_id.
        Defaults to False.

    Returns:
        pd.DataFrame: a frame which only containse the defined points.
    &#34;&#34;&#34;
    try:
        if use_orginal_id:
            point = self.data[self.data[&#34;original_id&#34;] == id]
            if len(point) == 0:
                raise IndexError
            elif len(point) != 1:
                raise Exception()
        else:
            point = pd.DataFrame(self.data.iloc[id]).transpose()
            point = point.astype(dict(self.data.dtypes))
    except IndexError:
        raise IndexError(f&#34;point with {id} does note exist.&#34;)
    except Exception:
        print(traceback.print_exc())
    return point.reset_index(drop=True)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.get_cluster"><code class="name flex">
<span>def <span class="ident">get_cluster</span></span>(<span>self, eps:Â float, min_points:Â int) â€‘>Â pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Get the clusters based on open3D cluster_dbscan. Process futher with
take_cluster.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code></dt>
<dd>Density parameter that is used to find neighbouring points.</dd>
<dt><strong><code>min_points</code></strong> :&ensp;<code>int</code></dt>
<dd>Minimum number of points to form a cluster.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Dataframe with list of clusters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cluster(self, eps: float, min_points: int) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Get the clusters based on open3D cluster_dbscan. Process futher with
        take_cluster.

    Args:
        eps (float): Density parameter that is used to find neighbouring points.
        min_points (int): Minimum number of points to form a cluster.

    Returns:
        pd.DataFrame: Dataframe with list of clusters.
    &#34;&#34;&#34;
    labels = np.array(
        self.get_open3d_points().cluster_dbscan(
            eps=eps, min_points=min_points, print_progress=False
        )
    )
    labels_df = pd.DataFrame(labels, columns=[&#34;cluster&#34;])
    return labels_df</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.get_open3d_points"><code class="name flex">
<span>def <span class="ident">get_open3d_points</span></span>(<span>self) â€‘>Â open3d.open3d_pybind.geometry.PointCloud</span>
</code></dt>
<dd>
<div class="desc"><p>Extract points as open3D PointCloud object. Needed for processing with the
open3d package.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>o3d.open3d_pybind.geometry.PointCloud</code></dt>
<dd>the pointcloud</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_open3d_points(self) -&gt; o3d.open3d_pybind.geometry.PointCloud:
    &#34;&#34;&#34;Extract points as open3D PointCloud object. Needed for processing with the
    open3d package.

    Returns:
        o3d.open3d_pybind.geometry.PointCloud: the pointcloud
    &#34;&#34;&#34;
    converted = convert.convert_df2pcd(self.points.points)
    assert len(np.asarray(converted.points)) == len(
        self
    ), &#34;len of open3d points should be the same as len of the Frame&#34;
    return convert.convert_df2pcd(self.points.points)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.has_data"><code class="name flex">
<span>def <span class="ident">has_data</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if lidar frame has data. Data here means point coordinates and
measruments at each point of the pointcloud.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>`True`` if the lidar frame contains measurment data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_data(self) -&gt; bool:
    &#34;&#34;&#34;Check if lidar frame has data. Data here means point coordinates and
    measruments at each point of the pointcloud.

    Returns:
        bool: `True`` if the lidar frame contains measurment data.
    &#34;&#34;&#34;
    return not self.data.empty</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.limit"><code class="name flex">
<span>def <span class="ident">limit</span></span>(<span>self, dim:Â "'str'", minvalue:Â float, maxvalue:Â float)</span>
</code></dt>
<dd>
<div class="desc"><p>Limit the range of certain values in lidar Frame. Can be chained together.</p>
<p>Example:</p>
<p>testframe.limit("x", -1.0, 1.0).limit("intensity", 0.0, 50.0)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>str</code></dt>
<dd>dimension to limit, any column in data not just x, y, or z</dd>
<dt><strong><code>minvalue</code></strong> :&ensp;<code>float</code></dt>
<dd>min value to limit. (greater equal)</dd>
<dt><strong><code>maxvalue</code></strong> :&ensp;<code>float</code></dt>
<dd>max value to limit. (smaller equal)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>limited frame, were columns which did not match the criteria were</dd>
</dl>
<p>dropped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limit(self, dim: &#34;str&#34;, minvalue: float, maxvalue: float):
    &#34;&#34;&#34;Limit the range of certain values in lidar Frame. Can be chained together.

    Example:

    testframe.limit(&#34;x&#34;, -1.0, 1.0).limit(&#34;intensity&#34;, 0.0, 50.0)

    Args:
        dim (str): dimension to limit, any column in data not just x, y, or z
        minvalue (float): min value to limit. (greater equal)
        maxvalue (float): max value to limit. (smaller equal)
    Returns:
        Frame: limited frame, were columns which did not match the criteria were
        dropped.
    &#34;&#34;&#34;
    if maxvalue &lt; minvalue:
        raise ValueError(&#34;maxvalue must be greater than minvalue&#34;)
    bool_array = (
        (self.data[dim] &lt;= maxvalue) &amp; (self.data[dim] &gt;= minvalue)
    ).to_numpy()
    return self.apply_filter(bool_array)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.plane_segmentation"><code class="name flex">
<span>def <span class="ident">plane_segmentation</span></span>(<span>self, distance_threshold:Â float, ransac_n:Â int, num_iterations:Â int, return_plane_model:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Segments a plane in the point cloud using the RANSAC algorithm.
Based on open3D plane segmentation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>distance_threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>Max distance a point can be from the plane model, and still be considered an inlier.</dd>
<dt><strong><code>ransac_n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of initial points to be considered inliers in each iteration.</dd>
<dt><strong><code>num_iterations</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of iterations.</dd>
<dt><strong><code>return_plane_model</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Return also plane model parameters. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code> or <code>dict</code></dt>
<dd>Frame with inliers or a dict of Frame with inliers and the plane parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plane_segmentation(
    self,
    distance_threshold: float,
    ransac_n: int,
    num_iterations: int,
    return_plane_model: bool = False,
):
    &#34;&#34;&#34;Segments a plane in the point cloud using the RANSAC algorithm.
    Based on open3D plane segmentation.

    Args:
        distance_threshold (float): Max distance a point can be from the plane model, and still be considered an inlier.
        ransac_n (int):  Number of initial points to be considered inliers in each iteration.
        num_iterations (int): Number of iterations.
        return_plane_model (bool, optional): Return also plane model parameters. Defaults to False.

    Returns:
        Frame or dict: Frame with inliers or a dict of Frame with inliers and the plane parameters.
    &#34;&#34;&#34;
    pcd = self.get_open3d_points()
    plane_model, inliers = pcd.segment_plane(
        distance_threshold=distance_threshold,
        ransac_n=ransac_n,
        num_iterations=num_iterations,
    )
    if len(self) &gt; 200:
        warnings.warn(
            &#34;&#34;&#34;Might not produce reproducable resuts, If the number of points
            is high. Try to reduce the area of interesst before using
            plane_segmentation. Caused by open3D.&#34;&#34;&#34;
        )
    inlier_Frame = self.select_by_index(inliers)
    if return_plane_model:
        return {&#34;Frame&#34;: inlier_Frame, &#34;plane_model&#34;: plane_model}
    else:
        return inlier_Frame</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.plot_interactive"><code class="name flex">
<span>def <span class="ident">plot_interactive</span></span>(<span>self, backend:Â strÂ =Â 'plotly', color:Â strÂ =Â 'intensity', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate either a plotly or pyntcloud 3D plot.
(Note: Plotly plots also give index of datapoint in pandas array when hovering
over datapoint)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>backend</code></strong> :&ensp;<code>str</code></dt>
<dd>specify either "plotly" or "pyntcloud" as plot environment</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the column in the data that should be used as color</dd>
</dl>
<p>array for plotly plots</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>List of distances for each point</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_interactive(
    self, backend: str = &#34;plotly&#34;, color: str = &#34;intensity&#34;, **kwargs
):
    &#34;&#34;&#34;Generate either a plotly or pyntcloud 3D plot.
    (Note: Plotly plots also give index of datapoint in pandas array when hovering
    over datapoint)

    Args:
        backend (str): specify either &#34;plotly&#34; or &#34;pyntcloud&#34; as plot environment
        color (str): name of the column in the data that should be used as color
        array for plotly plots

    Returns:
        np.array: List of distances for each point
    &#34;&#34;&#34;
    args = locals()
    args.update(kwargs)
    backend = args.pop(&#34;backend&#34;)
    if backend == &#34;pyntcloud&#34;:
        return pyntcloud_3d(self, **kwargs)
    elif backend == &#34;plotly&#34;:
        return plotly_3d(self, color=color, **kwargs)
    else:
        raise ValueError(&#34;wrong backend&#34;)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.plot_overlay"><code class="name flex">
<span>def <span class="ident">plot_overlay</span></span>(<span>self, frames_dict:Â dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Overlay the Frame with the plot(s) of other Frames. For example overlay the
plot with a frame which contains
a cluster or a plane. Best used with smaller pointclouds.</p>
<p>Example:</p>
<p>testframe.plot_overlay({"Plane": plane,"Cluster 1": cluster1,
"Cluster 2": cluster2})</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frames_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary in the form {"Name", Frame}.</dd>
</dl>
<p>Can be arbitrarly long,</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly.graph_objs._figure.Figure</code></dt>
<dd>The interactive plot with overlays.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_overlay(self, frames_dict: dict):
    &#34;&#34;&#34;Overlay the Frame with the plot(s) of other Frames. For example overlay the
    plot with a frame which contains
    a cluster or a plane. Best used with smaller pointclouds.

    Example:

    testframe.plot_overlay({&#34;Plane&#34;: plane,&#34;Cluster 1&#34;: cluster1,
    &#34;Cluster 2&#34;: cluster2})

    Args:
        frames_dict (dict): A dictionary in the form {&#34;Name&#34;, Frame}.
        Can be arbitrarly long,

    Returns:
        plotly.graph_objs._figure.Figure: The interactive plot with overlays.
    &#34;&#34;&#34;
    return plot_overlay(self, frames_dict=frames_dict)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.quantile_filter"><code class="name flex">
<span>def <span class="ident">quantile_filter</span></span>(<span>self, dim:Â str, relation:Â strÂ =Â &#x27;&gt;=&#x27;, cut_quantile:Â floatÂ =Â 0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Filtering based on quantile values of dimension dim of the data.</p>
<p>Example:</p>
<p>testframe.quantile_filter("intensity","==",0.5)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>str</code></dt>
<dd>column in data, for example "intensity"</dd>
<dt><strong><code>relation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Any operator as string. Defaults to "&gt;=".</dd>
<dt><strong><code>cut_quantile</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Qunatile to compare to. Defaults to 0.5.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>Frame which fullfils the criteria.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quantile_filter(
    self, dim: str, relation: str = &#34;&gt;=&#34;, cut_quantile: float = 0.5
):
    &#34;&#34;&#34;Filtering based on quantile values of dimension dim of the data.

    Example:

    testframe.quantile_filter(&#34;intensity&#34;,&#34;==&#34;,0.5)

    Args:
        dim (str): column in data, for example &#34;intensity&#34;
        relation (str, optional): Any operator as string. Defaults to &#34;&gt;=&#34;.
        cut_quantile (float, optional): Qunatile to compare to. Defaults to 0.5.

    Returns:
        Frame: Frame which fullfils the criteria.
    &#34;&#34;&#34;
    cut_value = self.data[dim].quantile(cut_quantile)
    filter_array = ops[relation](self.data[dim], cut_value)
    return self.apply_filter(filter_array.to_numpy())</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.remove_radius_outlier"><code class="name flex">
<span>def <span class="ident">remove_radius_outlier</span></span>(<span>self, nb_points:Â int, radius:Â float)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to remove points that have less than nb_points in a given
sphere of a given radius Parameters.</p>
<h2 id="args">Args</h2>
<p>nb_points (int) â€“ Number of points within the radius.
radius (float) â€“ Radius of the sphere.</p>
<h2 id="returns">Returns</h2>
<p>Tuple[open3d.geometry.PointCloud, List[int]] :</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_radius_outlier(self, nb_points: int, radius: float):
    &#34;&#34;&#34;    Function to remove points that have less than nb_points in a given
    sphere of a given radius Parameters.
    Args:
        nb_points (int) â€“ Number of points within the radius.
        radius (float) â€“ Radius of the sphere.
    Returns:
        Tuple[open3d.geometry.PointCloud, List[int]] :
    &#34;&#34;&#34;
    pcd = self.get_open3d_points()
    cl, index_to_keep = pcd.remove_radius_outlier(
        nb_points=nb_points, radius=radius
    )
    return self.select_by_index(index_to_keep)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.select_by_index"><code class="name flex">
<span>def <span class="ident">select_by_index</span></span>(<span>self, index_to_keep:Â List[int])</span>
</code></dt>
<dd>
<div class="desc"><p>Generating a new Frame by keeping index_to_keep.</p>
<p>Usefull for open3d generate index lists. Similar to the the select_by_index
function of open3d.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index_to_keep</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>List of indices to keep</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>Frame with kept rows and reindexed data and points</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_by_index(self, index_to_keep: List[int]):
    &#34;&#34;&#34;Generating a new Frame by keeping index_to_keep.

    Usefull for open3d generate index lists. Similar to the the select_by_index
    function of open3d.

    Args:
        index_to_keep (List[int]): List of indices to keep

    Returns:
        Frame: Frame with kept rows and reindexed data and points
    &#34;&#34;&#34;
    new_data = self.data.iloc[index_to_keep].reset_index(drop=True)
    return Frame(new_data, timestamp=self.timestamp)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.take_cluster"><code class="name flex">
<span>def <span class="ident">take_cluster</span></span>(<span>self, cluster_number:Â int, cluster_labels:Â pd.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes only the points belonging to the cluster_number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cluster_number</code></strong> :&ensp;<code>int</code></dt>
<dd>Cluster id to keep.</dd>
<dt><strong><code>cluster_labels</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>clusters generated with get_cluster.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></dt>
<dd>with cluster of ID cluster_number.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_cluster(self, cluster_number: int, cluster_labels: pd.DataFrame):
    &#34;&#34;&#34;Takes only the points belonging to the cluster_number.

    Args:
        cluster_number (int): Cluster id to keep.
        cluster_labels (pd.DataFrame): clusters generated with get_cluster.

    Returns:
        Frame: with cluster of ID cluster_number.
    &#34;&#34;&#34;
    bool_array = (cluster_labels[&#34;cluster&#34;] == cluster_number).values
    return self.apply_filter(bool_array)</code></pre>
</details>
</dd>
<dt id="lidar.frame.Frame.to_csv"><code class="name flex">
<span>def <span class="ident">to_csv</span></span>(<span>self, path:Â PathÂ =Â PosixPath('.'))</span>
</code></dt>
<dd>
<div class="desc"><p>Exports the frame as a csv for use with cloud compare or similar tools.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Path</code>, optional</dt>
<dd>Destination. Defaults to the folder of</dd>
</dl>
<p>the bag fiile with the timestamp of the frame.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_csv(self, path: Path = Path()):
    &#34;&#34;&#34;Exports the frame as a csv for use with cloud compare or similar tools.
    Args:
        path (Path, optional): Destination. Defaults to the folder of
        the bag fiile with the timestamp of the frame.
    &#34;&#34;&#34;
    orig_file_name = Path(self.orig_file).stem
    if path == Path():
        filename = f&#34;{orig_file_name}_timestamp_{self.timestamp}.csv&#34;
        destination_folder = Path(self.orig_file).parent.joinpath(filename)
    else:
        destination_folder = path
    self.data.to_csv(destination_folder, index=False)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#frame-class">Frame Class.</a><ul>
<li><a href="#developer-notes">Developer notes:</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lidar" href="index.html">lidar</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lidar.frame.Frame" href="#lidar.frame.Frame">Frame</a></code></h4>
<ul class="">
<li><code><a title="lidar.frame.Frame.add_column" href="#lidar.frame.Frame.add_column">add_column</a></code></li>
<li><code><a title="lidar.frame.Frame.apply_filter" href="#lidar.frame.Frame.apply_filter">apply_filter</a></code></li>
<li><code><a title="lidar.frame.Frame.calculate_distance_to_origin" href="#lidar.frame.Frame.calculate_distance_to_origin">calculate_distance_to_origin</a></code></li>
<li><code><a title="lidar.frame.Frame.calculate_distance_to_plane" href="#lidar.frame.Frame.calculate_distance_to_plane">calculate_distance_to_plane</a></code></li>
<li><code><a title="lidar.frame.Frame.convert_timestamp" href="#lidar.frame.Frame.convert_timestamp">convert_timestamp</a></code></li>
<li><code><a title="lidar.frame.Frame.data" href="#lidar.frame.Frame.data">data</a></code></li>
<li><code><a title="lidar.frame.Frame.describe" href="#lidar.frame.Frame.describe">describe</a></code></li>
<li><code><a title="lidar.frame.Frame.extract_point" href="#lidar.frame.Frame.extract_point">extract_point</a></code></li>
<li><code><a title="lidar.frame.Frame.get_cluster" href="#lidar.frame.Frame.get_cluster">get_cluster</a></code></li>
<li><code><a title="lidar.frame.Frame.get_open3d_points" href="#lidar.frame.Frame.get_open3d_points">get_open3d_points</a></code></li>
<li><code><a title="lidar.frame.Frame.has_data" href="#lidar.frame.Frame.has_data">has_data</a></code></li>
<li><code><a title="lidar.frame.Frame.limit" href="#lidar.frame.Frame.limit">limit</a></code></li>
<li><code><a title="lidar.frame.Frame.measurments" href="#lidar.frame.Frame.measurments">measurments</a></code></li>
<li><code><a title="lidar.frame.Frame.orig_file" href="#lidar.frame.Frame.orig_file">orig_file</a></code></li>
<li><code><a title="lidar.frame.Frame.plane_segmentation" href="#lidar.frame.Frame.plane_segmentation">plane_segmentation</a></code></li>
<li><code><a title="lidar.frame.Frame.plot_interactive" href="#lidar.frame.Frame.plot_interactive">plot_interactive</a></code></li>
<li><code><a title="lidar.frame.Frame.plot_overlay" href="#lidar.frame.Frame.plot_overlay">plot_overlay</a></code></li>
<li><code><a title="lidar.frame.Frame.points" href="#lidar.frame.Frame.points">points</a></code></li>
<li><code><a title="lidar.frame.Frame.quantile_filter" href="#lidar.frame.Frame.quantile_filter">quantile_filter</a></code></li>
<li><code><a title="lidar.frame.Frame.remove_radius_outlier" href="#lidar.frame.Frame.remove_radius_outlier">remove_radius_outlier</a></code></li>
<li><code><a title="lidar.frame.Frame.select_by_index" href="#lidar.frame.Frame.select_by_index">select_by_index</a></code></li>
<li><code><a title="lidar.frame.Frame.take_cluster" href="#lidar.frame.Frame.take_cluster">take_cluster</a></code></li>
<li><code><a title="lidar.frame.Frame.timestamp" href="#lidar.frame.Frame.timestamp">timestamp</a></code></li>
<li><code><a title="lidar.frame.Frame.to_csv" href="#lidar.frame.Frame.to_csv">to_csv</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>